#Used to select atoms for pie chart
#Select rows from a df based on indices
import pandas as pd
import numpy as np
from scipy.spatial import ConvexHull

from .data import df_from_path
from .utils import Trajectory
from .vertices import load_directory_convex

def select_atom_indices(df,indices,atomcount):
    """
    This function takes a dataframe generated by df_from_path or df_from_points 
    and selects the rows corresponding to specified atom indices
    Inputs:
        df (pandas dataframe): output from df_from_path or df_from_points
        indices (list): list of atom indices
        atomcount(integer): number of atoms in the molecule
    Outputs:
        df (pandas dataframe): dataframe only containing data for the selected atoms
    """
    overall_property_count = 6 #Number of rows at the top of the df containing sums/averages
    selected_indices = [False for i in range(len(df[overall_property_count:]))]
    atom_indices = indices
    
    for atom_index in atom_indices:
        edit_indices = [i for i in range(len(df[overall_property_count:])) if i%atomcount==atom_index]
        for edit in edit_indices:
            selected_indices[edit] = True

#     return pd.concat([df[:overall_property_count],df[overall_property_count:][selected_indices]],axis=0) #concatenate the dfs
    return df[overall_property_count:][selected_indices]
    
def select_element(df,element):
    """
    This function takes a dataframe generated by df_from_path or df_from_points
    and selects the rows corresponding to a specified element
    Inputs:
        df (pandas dataframe): output from df_from_path or df_from_points
        element (string): element symbol e.g. C, H, N, O
    Outputs:
        (pandas dataframe): dataframe only containing data for the selected element
    """
    overall_property_count=6 #number of rows at the top before atomic properties

    selected_indices = df[overall_property_count:].index.str.startswith(element)
    return pd.concat([df[:overall_property_count],df[overall_property_count:][selected_indices]],axis=0)
    
def functional_group_nonoverlapping_volume(xyzpath, indices):
    """
    This function takes an xyz trajectory and calculates the convex hull volume of a
    functional group as the sum of atomic convex hull volumes
    Inputs:
        xyzpath (string): path to an XYZ trajectory
        indices (list): list of atom indices of the atoms in the functional group
    Outputs:
        volume (float): sum of atomic convex hull volumes    
    """
    df = df_from_path(xyzpath)
    _,atom_names = Trajectory(xyzpath)
    atomcount = len(atom_names)
    
    group_df = select_atom_indices(df,indices,atomcount)
    
    group_volume = sum(group_df[:len(indices)].values)
#     return group_df
    return group_volume[0]
    
def functional_group_overlapping_volume(xyzpath, indices):
    """
    This function takes an xyz trajectory and calculates the convex hull volume of a
    functional group by pooling the points of all the atoms into one point cloud and
    finding its convex hull
    Inputs:
        xyzpath (string): path to an xyz trajectory
        indices (list): list of atom indices of the atoms in the functional group
    Outputs:
        volume (float): volume of the convex hull containing all of the atoms in the functional group
    """
    selected_points = []

    traj_coords, atom_names = Trajectory(xyzpath)
    
    atomcount = traj_coords.shape[1] #getting number of atoms from the shape of the array
    newshape = traj_coords.shape[0]*traj_coords.shape[1] #number of geometries * number of atoms
    
    #Check the indexing here?
    for i,point in enumerate(traj_coords.reshape(newshape,3)):
        if (i%atomcount in indices): #if the number is in the list of indices
    #         print(i+1)
            selected_points.append(point)

    selected_points = np.array(selected_points)
    hull = ConvexHull(selected_points)
    volume = hull.volume

#     print(selected_points.shape) #should be 80,000,3 since CH4 is 4 atoms*20k geometries
    return volume
    
def in_hull(p, hull):
    """
    Taken from stackoverflow https://stackoverflow.com/a/16898636
    Test if points in `p` are in `hull`

    `p` should be a `NxK` coordinates of `N` points in `K` dimensions
    `hull` is either a scipy.spatial.Delaunay object or the `MxK` array of the 
    coordinates of `M` points in `K`dimensions for which Delaunay triangulation
    will be computed
    """
    from scipy.spatial import Delaunay
    if not isinstance(hull,Delaunay):
        hull = Delaunay(hull)

    return hull.find_simplex(p)>=0
    
def functional_group_overlap_check(hull_vertices_dir, indices):
    """
    This function takes a directory containing the convex hull vertices' CSVs and atom indices, and
    outputs True/False based on whether the convex hulls of any pairs of atoms overlap, as well as
    lists of tuples of atoms with overlapping convex hulls; if the list is empty it means there are no overlaps
    Inputs: 
        hull_vertices_dir (string): directory of CSVs generated by save_vertices_points
        indices (list): list of atom indices of the atoms in the functional group
    Outputs:
        True/False: whether any pairs of atoms have overlapping convex hulls
        overlap_pairs (list): list of tuples of atoms with overlapping convex hulls
    """
    import itertools
    atomnames, points, vertices = load_directory_convex(hull_vertices_dir)
    combos = itertools.combinations([i for i in indices],2)
#     print([i for i in combos])
    overlaps = []
    overlap_pairs = []
    for combo in combos:
#         print(sum(in_hull(vertices[combo[0]],vertices[combo[1]])))
        overlap_count = sum(in_hull(vertices[combo[0]],vertices[combo[1]])) #how many vertices of a are inside hull b
        overlaps.append(overlap_count)
        if overlap_count != 0:
            overlap_pairs.append((atomnames[combo[0]],atomnames[combo[1]]))
    return sum(overlaps)!=0 , overlap_pairs